spec_version: "v1.3"
creation_date: "2026-02-07T10:00:00Z"
dataset_type: "CostAndUsage"
dataset_instance_name: "Hourly Billing Report v1.3"

# Global validation defaults - different from v1.2 for testing
validation:
  default:
    presence:
      enforce: true
    nullable:
      allow_nulls: false
    string:
      allow_empty: false
      min_length: 1
      max_length: 255
    decimal:
      scale: 2
      precision: 20
    allowed_values:
      case_insensitive: true

mappings:
  # v1.3 mandatory columns using telemetry_small.csv source columns
  # Covers all op types: from_column, const, null, coalesce, map_values, concat, cast, round, math, when, pandas_expr

  # Use 'const' op
  HostProviderName:
    steps:
      - op: const
        value: "AcmeDC"

  ServiceProviderName:
    steps:
      - op: const
        value: "AcmeDC"

  # Use 'from_column' + 'cast' ops
  BillingAccountId:
    steps:
      - op: from_column
        column: tag_a
      - op: cast
        to: string

  BillingAccountName:
    steps:
      - op: const
        value: "Acme Billing"

  InvoiceIssuerName:
    steps:
      - op: const
        value: "AcmeDC"

  # Use 'from_column' + 'cast' 
  BillingCurrency:
    steps:
      - op: from_column
        column: billing_currency
      - op: cast
        to: string

  # Keep billing/charge period mappings unchanged from v1_2
  BillingPeriodStart:
    steps:
      - op: pandas_expr
        expr: 'pd.to_datetime(df["billing_period"] + "-01", utc=True)'
      - op: cast
        to: datetime

  BillingPeriodEnd:
    steps:
      - op: pandas_expr
        expr: 'pd.to_datetime((df["billing_period"].str.slice(0,4).astype(int) + ((df["billing_period"].str.slice(5,7).astype(int) + 1) > 12).astype(int)).astype(str) + "-" + (((df["billing_period"].str.slice(5,7).astype(int) + 1 - 1) % 12) + 1).astype(str).str.replace(r"^(\\d)$", r"0\\1", regex=True) + "-01", utc=True)'
      - op: cast
        to: datetime

  ChargePeriodStart:
    steps:
      - op: sql
        expr: "TRY_CAST(billing_date || 'T' || LPAD(CAST(billing_hour AS VARCHAR), 2, '0') || ':00:00Z' AS TIMESTAMPTZ)"
      - op: cast
        to: datetime

  ChargePeriodEnd:
    steps:
      - op: sql
        expr: "TRY_CAST(billing_date || 'T' || LPAD(CAST(billing_hour AS VARCHAR), 2, '0') || ':00:00Z' AS TIMESTAMPTZ) + INTERVAL 1 HOUR"
      - op: cast
        to: datetime

  # Use 'from_column' only
  ChargeCategory:
    steps:
      - op: from_column
        column: charge_category

  # Use 'null' op - must quote "null" in YAML
  ChargeClass:
    steps:
      - op: "null"
    # Override global: allow nulls for this nullable column
    validation:
      nullable:
        allow_nulls: true

  # Use 'const'
  ChargeDescription:
    steps:
      - op: from_column
        column: charge_description

  ServiceCategory:
    steps:
      - op: const
        value: "Compute"

  ServiceName:
    steps:
      - op: const
        value: "VirtualMachine"

  # Use 'from_column' + 'cast' with decimal
  PricingQuantity:
    steps:
      - op: from_column
        column: pricing_quantity
      - op: cast
        to: decimal
        scale: 0

  PricingUnit:
    steps:
      - op: from_column
        column: pricing_unit
      - op: cast
        to: string

  BilledCost:
    steps:
      - op: from_column
        column: billed_cost
      - op: cast
        to: decimal
        scale: 2
    # Per-column validation: cost constraints
    validation:
      decimal:
        min: 0
        max: 1000000

  EffectiveCost:
    steps:
      - op: sql
        expr: "billed_cost + tax_amount"
      - op: cast
        to: decimal
        scale: 2

  ContractedCost:
    steps:
      - op: from_column
        column: billed_cost
      - op: cast
        to: decimal
        scale: 2

  ListCost:
    steps:
      - op: from_column
        column: billed_cost
      - op: cast
        to: decimal
        scale: 2

  # Extension columns testing various ops

  # Use 'coalesce' op
  x_CoalescedDescription:
    description: "Coalesce alt_description then charge_description"
    steps:
      - op: coalesce
        columns: ["alt_description", "charge_description"]

  # Use 'map_values' op
  x_MappedCategory:
    description: "Map charge_category to short code"
    steps:
      - op: map_values
        column: charge_category
        mapping:
          Usage: "U"
          Tax: "T"
        default: "Other"

  # Use 'concat' op
  x_TagConcat:
    description: "Concat tag_a and tag_b"
    steps:
      - op: concat
        columns: ["tag_a", "tag_b"]
        sep: "-"
    # Per-column validation: limit concatenated string length
    validation:
      string:
        max_length: 50

  # Use 'round' op
  x_RoundedTax:
    description: "Rounded tax amount"
    steps:
      - op: from_column
        column: tax_amount
      - op: round
        ndigits: 1

  # Use 'math' op
  x_MathTotal:
    description: "Total cost using math op"
    steps:
      - op: math
        operator: add
        operands:
          - column: billed_cost
          - column: tax_amount

  # Use 'when' op
  x_WhenTax:
    description: "Flag rows that are tax"
    steps:
      - op: when
        column: charge_category
        value: "Tax"
        then: "Y"
        else: "N"

  # Use 'sql' query mode
  x_QueryTotal:
    description: "Total cost using sql query"
    steps:
      - op: sql
        query: "SELECT billed_cost + tax_amount FROM src"

  # Enriched data mappings
  ResourceId:
    steps:
      - op: from_column
        column: billing_resource_id

  x_DailyTotalCost:
    description: "Daily total cost per resource using window function"
    steps:
      - op: sql
        query: "SELECT SUM(billed_cost) OVER (PARTITION BY billing_resource_id, billing_date ORDER BY billing_date) FROM src ORDER BY billing_resource_id, billing_date"
